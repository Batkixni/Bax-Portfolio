const fs = require("fs-extra");
const path = require("path");
const exifr = require("exifr");

class PhotoManager {
  constructor(photographyDir) {
    this.photographyDir = photographyDir;
    this.imagesDir = path.join(photographyDir, "images");
    this.infoPath = path.join(photographyDir, "photo-info.json");
    this.supportedExtensions = [".jpg", ".jpeg", ".png", ".tiff", ".tif"];
  }

  async init() {
    // Ensure directories exist
    await fs.ensureDir(this.imagesDir);

    // Initialize JSON file if it doesn't exist
    if (!(await fs.pathExists(this.infoPath))) {
      await this.createInitialJson();
    }
  }

  async createInitialJson() {
    const initialData = {
      photos: {},
      _metadata: {
        lastUpdated: new Date().toISOString(),
        version: "1.0.0",
        autoGenerated: true,
      },
    };

    await fs.writeJson(this.infoPath, initialData, { spaces: 2 });
  }

  async scanAndUpdatePhotos() {
    try {
      await this.init();

      // Get current JSON data
      let photoData = await this.loadPhotoData();

      // Ensure photos object exists
      if (!photoData.photos) {
        photoData.photos = {};
      }

      // Get all image files
      const imageFiles = await this.getImageFiles();

      // Track changes
      let hasChanges = false;

      for (const filename of imageFiles) {
        const filePath = path.join(this.imagesDir, filename);

        // Check if photo already exists in JSON
        if (!photoData.photos[filename]) {
          console.log(`Find New Images: ${filename}`);

          // Create new entry for this photo
          const photoInfo = await this.createPhotoEntry(filePath, filename);
          photoData.photos[filename] = photoInfo;
          hasChanges = true;
        } else {
          // Check if we need to update EXIF data
          const existingPhoto = photoData.photos[filename];
          if (
            !existingPhoto.exif ||
            Object.keys(existingPhoto.exif || {}).length === 0
          ) {
            console.log(`Update EXIF Information: ${filename}`);

            const exifData = await this.extractExif(filePath);
            if (exifData) {
              photoData.photos[filename].exif = exifData;
              hasChanges = true;
            }
          }
        }
      }

      // Remove entries for deleted photos
      const existingPhotos = Object.keys(photoData.photos || {});
      for (const filename of existingPhotos) {
        if (!imageFiles.includes(filename)) {
          console.log(`Delete Not Exist Images: ${filename}`);
          delete photoData.photos[filename];
          hasChanges = true;
        }
      }

      // Update metadata and save if there are changes
      if (hasChanges) {
        photoData._metadata = {
          ...photoData._metadata,
          lastUpdated: new Date().toISOString(),
          totalPhotos: imageFiles.length,
        };

        await fs.writeJson(this.infoPath, photoData, { spaces: 2 });
        console.log(`Updated ${imageFiles.length} image informations`);
      } else {
        console.log("All image data is up to date");
      }

      return photoData;
    } catch (error) {
      console.error("Error when scan the image:", error);
      throw error;
    }
  }

  async loadPhotoData() {
    try {
      const data = await fs.readJson(this.infoPath);
      return data;
    } catch (error) {
      console.log("Can not read the image info, creating new now");
      return {
        photos: {},
        _metadata: {
          lastUpdated: new Date().toISOString(),
          version: "1.0.0",
          autoGenerated: true,
        },
      };
    }
  }

  async getImageFiles() {
    try {
      const files = await fs.readdir(this.imagesDir);
      return files.filter((file) =>
        this.supportedExtensions.some((ext) =>
          file.toLowerCase().endsWith(ext),
        ),
      );
    } catch (error) {
      console.error("Failed to read the image catalog:", error);
      return [];
    }
  }

  async createPhotoEntry(filePath, filename) {
    const stats = await fs.stat(filePath);
    const exifData = await this.extractExif(filePath);

    // Generate default title from filename
    const defaultTitle = filename
      .replace(/\.[^/.]+$/, "") // Remove extension
      .replace(/[-_]/g, " ") // Replace hyphens and underscores with spaces
      .replace(/\b\w/g, (l) => l.toUpperCase()); // Capitalize first letter of each word

    return {
      title: defaultTitle,
      description: "",
      exif: exifData || {},
      tags: [],
      fileInfo: {
        size: stats.size,
        created: stats.birthtime.toISOString(),
        modified: stats.mtime.toISOString(),
      },
      autoGenerated: true,
    };
  }

  async extractExif(filePath) {
    try {
      const exifData = await exifr.parse(filePath, {
        pick: [
          // Camera info
          "Make",
          "Model",
          // Lens info
          "LensModel",
          "LensMake",
          // Settings
          "FocalLength",
          "FNumber",
          "ExposureTime",
          "ISO",
          // Date
          "DateTimeOriginal",
          "CreateDate",
          "DateTime",
          // Other useful info
          "Flash",
          "WhiteBalance",
          "ColorSpace",
          "ImageWidth",
          "ImageHeight",
          "Orientation",
        ],
      });

      if (!exifData) {
        return null;
      }

      // Format the EXIF data for our use
      const formattedExif = {};

      // Camera
      if (exifData.Make && exifData.Model) {
        formattedExif.camera = `${exifData.Make} ${exifData.Model}`;
      } else if (exifData.Model) {
        formattedExif.camera = exifData.Model;
      }

      // Lens
      if (exifData.LensModel) {
        formattedExif.lens = exifData.LensModel;
      } else if (exifData.LensMake) {
        formattedExif.lens = exifData.LensMake;
      }

      // Focal length
      if (exifData.FocalLength) {
        formattedExif.focal_length = `${Math.round(exifData.FocalLength)}mm`;
      }

      // Aperture
      if (exifData.FNumber) {
        formattedExif.aperture = `f/${exifData.FNumber}`;
      }

      // Shutter speed
      if (exifData.ExposureTime) {
        if (exifData.ExposureTime >= 1) {
          formattedExif.shutter_speed = `${exifData.ExposureTime}s`;
        } else {
          formattedExif.shutter_speed = `1/${Math.round(1 / exifData.ExposureTime)}s`;
        }
      }

      // ISO
      if (exifData.ISO) {
        formattedExif.iso = exifData.ISO.toString();
      }

      // Date taken
      const dateFields = ["DateTimeOriginal", "CreateDate", "DateTime"];
      for (const field of dateFields) {
        if (exifData[field]) {
          const date = new Date(exifData[field]);
          if (!isNaN(date.getTime())) {
            formattedExif.date_taken = date.toISOString().split("T")[0]; // YYYY-MM-DD format
            break;
          }
        }
      }

      // Image dimensions
      if (exifData.ImageWidth && exifData.ImageHeight) {
        formattedExif.dimensions = `${exifData.ImageWidth} × ${exifData.ImageHeight}`;
      }

      // Flash
      if (exifData.Flash !== undefined) {
        formattedExif.flash = exifData.Flash === 0 ? "關閉" : "開啟";
      }

      return formattedExif;
    } catch (error) {
      console.warn(
        `Can not read file ${path.basename(filePath)} 's information:`,
        error.message,
      );
      return null;
    }
  }

  async updatePhotoInfo(filename, updates) {
    try {
      const photoData = await this.loadPhotoData();

      if (!photoData.photos[filename]) {
        throw new Error(`Image ${filename} is not exist`);
      }

      // Merge updates
      photoData.photos[filename] = {
        ...photoData.photos[filename],
        ...updates,
        autoGenerated: false, // Mark as manually updated
      };

      // Update metadata
      photoData._metadata.lastUpdated = new Date().toISOString();

      await fs.writeJson(this.infoPath, photoData, { spaces: 2 });

      console.log(`Updated: ${filename}`);
      return photoData.photos[filename];
    } catch (error) {
      console.error("Error when updating the image information:", error);
      throw error;
    }
  }

  async getPhotoInfo(filename) {
    const photoData = await this.loadPhotoData();
    return photoData.photos[filename] || null;
  }

  async getAllPhotos() {
    const photoData = await this.loadPhotoData();
    return photoData.photos;
  }

  // Method to be called periodically or on server start
  async autoUpdate() {
    console.log("Start to auto updating image info...");
    try {
      await this.scanAndUpdatePhotos();
      console.log("Update complete");
    } catch (error) {
      console.error("Update failed:", error);
    }
  }

  // Watch for file changes (optional)
  watchForChanges() {
    if (!fs.existsSync(this.imagesDir)) {
      return;
    }

    const chokidar = require("chokidar");
    const watcher = chokidar.watch(this.imagesDir, {
      ignored: /(^|[\/\\])\../, // ignore dotfiles
      persistent: true,
    });

    watcher
      .on("add", (filePath) => {
        const filename = path.basename(filePath);
        if (
          this.supportedExtensions.some((ext) =>
            filename.toLowerCase().endsWith(ext),
          )
        ) {
          console.log(`Scan the new image: ${filename}`);
          this.autoUpdate();
        }
      })
      .on("unlink", (filePath) => {
        const filename = path.basename(filePath);
        console.log(`Scanned the image got delete: ${filename}`);
        this.autoUpdate();
      });

    console.log(`Start to detect the image catalogs: ${this.imagesDir}`);
    return watcher;
  }
}

module.exports = PhotoManager;
